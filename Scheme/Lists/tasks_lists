t), която взима n-тия елемент на даден списък:
(nth 0 '(1 2 3)) -> 1
(nth 5 '(1 2 3)) -> #f
Зад.3. Да се напише функция (range from to), която връща списъка с естествени числа в интервала [from;to]:
(range 5 10) -> '(5 6 7 8 9 10)
Зад.4. Да се напише функция (digit-list n), която връща цифрите на число в списък:
(digit-list 1806) -> '(1 8 0 6)
Зад.5. Да се напише функциите (take n lst) и (drop n lst), който съответно взимат или премахват първите n елемента на списък:
(take 3 (range 1 5)) -> '(1 2 3)
(take 10 (range 1 5)) -> '(1 2 3 4 5)
(drop 3 (range 1 5)) -> '(4 5)
(drop 10 (range 1 5)) -> '()
Зад.6. Да се напише функция (chunk n lst), която "разбива" списъка lst на подсписъци с дължина n (само последният може да е непълен):
(chunk 4 (range 1 10)) -> '((1 2 3 4) (5 6 7 8) (9 10))
Зад.7. Да се напишат функциите (all p? lst) и (any p? lst), които проверяват съответно дали всички или някои елементи на даден списък изпълняват предиката p?:
(all even? '(1 2 3 4 5)) -> #f
(any even? '(1 2 3 4 5)) -> #t
(any (lambda (x) (> x 10)) '(4 2 6 3 1)) -> #f
Зад.8. Да се напише функция (zip lst1 lst2), която приема два списъка и връща списък от наредени двойки от техните съответни елементи:
(zip '(1 2 3 4) '(#t #f #f)) -> '((1 . #t) (2 . #f) (3 . #f))
Зад.9. Да се напишат функциите (remove-first val lst) и (remove-all val lst), които премахват съотв. първото или всички срещания на елемента val в списъка lst:
(remove-first 1 '(2 1 3 2 4 1 2 1)) -> '(2 3 2 4 1 2 1)
(remove-all 1 '(2 1 3 2 4 1 2 3)) -> '(2 3 2 4 2))
Зад.10. Нека lst е списък от списъци с числа. Да се напише функцията (sum-of-sums lst), която връща списък от всички суми в тези списъци:
(sum-of-sums '((1 2 3) (0) (5 4 2 7))) -> '(6 0 18)
Зад.11. Да се напише функция (extract-ints lst), която взема списък с произволни обекти и връща списък, съставен само от числата в него:
(extract-ints '(1 2 #t "Hello" (3 "no") #f 4 (5))) -> (1 2 4)
Зад.12. Да се напише функция (insert val lst), която вмъква стойността val на правилното място в сортирания списък lst:
(insert 5 '(1 4 10)) -> '(1 4 5 10)
(insert 12 '(1 4 10)) -> '(1 4 10 12))
Зад.13. Да се напише функция (insertion-sort lst), която прави точно това, което подсказва името й:
(insertion-sort '(4 3 6 2 1 8 10)) -> '(1 2 3 4 6 8 10)
Зад.14. Да се напише функция с произволен брой аргументи (my-arity . xs), която при всяко извикване връща броя на подадените ѝ аргументи:
(my-arity 1 2 #f "iei" (3 5)) -> 5
Зад.15. Да се напише функция (compose . fns), която приема произволен брой функции като аргументи и връща тяхната композиция:
(define f (compose ++ ++ (lambda (x) (* x 2)) --))
(f 5) -> 18
Зад.16. Да се напише функция (group-by-f f lst), която групира елементите на списъка lst по стойността, която f връща за тях:
(group-by-f even? '(1 2 3 4 5)) -> ((#f (1 3 5))
                                    (#t (2 4))) ; подредбата няма значение
(group-by-f length '((1 2 3) (4) (5 6 7))) -> '((1 ((4)))
                                                (3 ((1 2 3) (5 6 7))))
